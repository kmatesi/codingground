/*********************************************************************
 * 
 *      Capital One Mindo Sumo Challenge
 *      
 *      File:   CapitalOne.cs
 *      Author: Kevin Matesi
 *      Date:   11/26/2014
 *      
 *      This program will query the SportsData API via an 
 *      HTTP GET request. An xml document is retrieved and 
 *      deserialized into an object array through the use of 
 *      the System.Xml class. 
 *      
 *      There are two reports that are output from this 
 *      program to demonstrate how to use the supplied objects
 *      and methods:
 *       + Teams from a specific conference in a division
 *       + Teams from an entiredivision
 *       
 *      Report format:
 *      Team Name              W   L   PF   PA
 *      ---------              -   -   --   --
 *      xxxxxxxxxxxxxxxxxxxx 999 999 9999 9999
 *      
 *      Note: The teams are sorted by their win percentage,
 *      number of wins, net points, and then alphabetically in
 *      that order.
 * 
 *      HTTP GET request syntax for SportsData API:
 *      http://api.sportsdatallc.org/ncaafb-[access_level][version]/teams/[division]/[year]/[ncaafb_season]/standings.[format]?api_key=[your_api_key]
 *      [access_level] = Real-Time (rt), Premium (p), Standard (s), Basic (b), Trial (t)
 *      [version] = whole number (sequential, starting with the number 1)
 *      [division] = "FBS" or "FCS"
 *      [year] = yyyy
 *      [ncaafb_season] = Preseason (PRE), Regular Season (REG), Postseason (PST) - Note: PST used for seasons 2012 and prior
 *      [format] = xml, json
 *       
*********************************************************************/

using System;
using System.Net;
using System.IO;
using System.Xml;
using System.Xml.Serialization;
using System.Text;
using System.Collections.Generic;

namespace CapitalOne
{
    /// <summary>
    /// This is the main class of the program that contains the entry point for the program.
    /// </summary>
    /// <remarks>
    /// A new instance of the XmlProcess class will be instantiated. Then it will be used to
    /// generate a xml string from the response of a HTTP GET query. Then a new Standings object
    /// is instantiated by deserializing the xml string. If the deserialization was successful,
    /// then a conference report is printed out, followed by a report of all the teams in a
    /// division.
    /// </remarks>
    public class Program
    {
        /// <summary>
        /// Format for the two reports generated by this program.
        /// </summary>
        const string FORMAT = "{0,-20} {1,3} {2,3} {3,4} {4,4}";                      

        /// <summary>
        /// The entry point for the program.
        /// </summary>
        /// <param name="args">unused</param>
        static void Main(string[] args)
        {
            XmlProcess xml = new XmlProcess();                          // create XmlProcess for building and sending a HTTP GET request 
            string xmlstring = xml.GetXmlResponse("FBS", "2014", "REG");    // send GET request to SportsData API and set xmlstring

            if (xmlstring != null)                                      // make sure there was an xml string created from the response
            {
                Standings standings = xml.deserializeXml(xmlstring);    // deserialize xml string into a standings object

                if (standings != null)                                  // make sure the xml was deserialized correctly
                {
                    Console.WriteLine("\nAll Division Report\n");       // print out title to report
                    displayAllTeams(standings);                         // print division report
                
                    Console.WriteLine("\nBIG-TEN Conference Report\n"); // print out title to report
                    displayConference(standings, "BIG-TEN");            // print conference report
                }//endif
            }//endif
            
            Console.WriteLine("\n*** Check the output txt files for the two example reports ***");
        }//endmain

        /// <summary>
        /// This method will print out a report for all the teams
        /// in a division.
        /// </summary>
        /// <remarks>
        /// This method will first pull all of the Team objects into
        /// a generic list, which will then be sorted using a recursive
        /// quick sort algorithm. Then the report will print out the teams
        /// in descending order, based on win percentage,
        /// wins, net points, alphabetically. In addition to printing out to the 
        /// console, a file will be created with a copy of the report.
        /// </remarks>
        /// <param name="s">
        /// Standings object that contains all of the conferences and
        /// associated teams.
        /// </param>
        public static void displayAllTeams(Standings s)
        {
            List<Team> teamList = listTeams(s);         // get the teams into a generic list
            sort(teamList, 0, teamList.Count - 1);      // sort the teams by win pct, wins, net points, alphabetically

            string headers = string.Format(FORMAT,      // create the header
                               "Team Name",
                               "W",
                               "L",
                               "PF",
                               "PA");
            string underline = string.Format(FORMAT,    // create the header underlines
                                            "---------",
                                            "-",
                                            "-",
                                            "--",
                                            "--");

            // create the file, overwrite it if it exists
            FileStream report = new FileStream("All_Teams_Report.txt", FileMode.Create, FileAccess.Write);
            StreamWriter sw = new StreamWriter(report); // set up the stream to write to the file

            Console.WriteLine(headers);                 // ouptut the header
            Console.WriteLine(underline);               // output the underlines
            sw.WriteLine(headers);                      // write header to file
            sw.WriteLine(underline);                    // write underlines to file

            foreach (Team t in teamList)                // cycle through each team in the list
            {
                string output = string.Format(FORMAT,   // build the team line for the report
                                              t.Name,
                                              t.Overall.Wins,
                                              t.Overall.Losses,
                                              t.Points.For,
                                              t.Points.Against);
                Console.WriteLine(output);              // output the team to console
                sw.WriteLine(output);                   // write to file
            }//endforeach

            sw.Close();     // close the stream
            report.Close(); // close the report file

        }//endmethod

        /// <summary>
        /// This method will print out a report for all the teams
        /// in a specific conference.
        /// </summary>
        /// <remarks>
        /// This method will first search through the standings object for
        /// the matching conference object. If found, all the teams will be printed
        /// out (they are already in order). If not found, a message will be printed
        /// to alert the user. In addition to printing out to the console, a file will
        /// be created with a copy of the report.
        /// </remarks>
        /// <param name="s">Standings object that holds all of the teams</param>
        /// <param name="conference">Conference ID of the conference to print out</param>
        public static void displayConference(Standings s, string conference)
        {
            bool found = false;                         // flags if the conference was found or not
            string headers = string.Format(FORMAT,      // build header
                                           "Team Name",
                                           "W",
                                           "L",
                                           "PF",
                                           "PA");
            string underline = string.Format(FORMAT,    // build header underlines
                                            "---------",
                                            "-",
                                            "-",
                                            "--",
                                            "--");

            foreach (Conference c in s.Division.Conference) // search through all the conferences
            {
                if (c.Id == conference)                     // check for a matching conference ID
                {
                    // create the file, overwrite it if it exists
                    FileStream report = new FileStream(conference + "_Conference_Report.txt", FileMode.Create, FileAccess.Write);
                    StreamWriter sw = new StreamWriter(report); // set up the stream to write to the file

                    Console.WriteLine(headers);             // print header
                    Console.WriteLine(underline);           // print underlines
                    sw.WriteLine(headers);                  // write header to file
                    sw.WriteLine(underline);                // write underlines to file


                    foreach (Team t in c.Team)              // cycle through each team to generate report
                    {
                        string output = string.Format(FORMAT,   // build team output
                                                      t.Name,
                                                      t.Overall.Wins,
                                                      t.Overall.Losses,
                                                      t.Points.For,
                                                      t.Points.Against);
                        Console.WriteLine(output);          // print team output
                        sw.WriteLine(output);
                    }//endforeach

                    sw.Close();     // close the stream
                    report.Close(); // close the report file

                    found = true;                           // flag that a match was found
                    break;                                  // don't iterate through any more conferences
                }//endif
            }//endforeach

            if (!found)                                     // check to see if a match was found
                Console.WriteLine("Error: Conference ID not found!");
        }//endmethod

        /// <summary>
        /// Recursively quick sort a generic list object.
        /// </summary>
        /// <remarks>
        /// This program will use recursive quick sort algorithm to efficiently
        /// sort the list of teams in descending order.
        /// </remarks>
        /// <param name="teamList">List of Team objects to be sorted</param>
        /// <param name="left">Where to start sorting</param>
        /// <param name="right">Where to stop sorting</param>
        private static void sort(List<Team> teamList, int left, int right)
        {
            int i = left;                               // keep left value, and use i to increment through the list
            int j = right;                              // keep right value, and use j to increment through the list
            Team pivot = teamList[(left + right) / 2];  // pick the pivot object to compare against

            while (i <= j)                              // keep looping until a swap is found
            {
                while (teamList[i] > pivot)             // check if object at [i] should precrede pivot
                    i++;                                // if yes, increment i
                while (teamList[j] < pivot)             // check if object at [j] shold precred pivot
                    j--;                                // if yes, increment j
                if (i <= j)                             // once we have found where to swap
                {
                    Team temp = teamList[i];            // set a temp Team object to hold object at [i] index
                    teamList[i] = teamList[j];          // swap
                    teamList[j] = temp;                 // finish swap
                    i++;                                // increment i
                    j--;                                // decrement j
                }//endif
            }//endwhile
            if (left < j)                   // check if a new partition needs to be sorted
                sort(teamList, left, j);    // sort a new partition
            if (i < right)                  // check if a new partition needs to be sorted
                sort(teamList, i, right);   // sort a new partition
        }//endmethod

        /// <summary>
        /// Method to convert a Standings object into a generic list of Team objects.
        /// </summary>
        /// <remarks>
        /// This method will first create a new Generic List of type Team. Then,
        /// by two foreach loops, it will cycle through all the teams in the 
        /// Standings object, and add them to a generic list. This list will
        /// be unsorted.
        /// </remarks>
        /// <param name="s">Standings object to convert into a List of Team objects</param>
        /// <returns>The unordered list of Team Objects</returns>
        private static List<Team> listTeams(Standings s)
        {
            List<Team> list = new List<Team>();                 // create a new generic list

            foreach (Conference c in s.Division.Conference)     // cycle through each conference 
            {
                foreach (Team t in c.Team)                      // cycle through each team
                    list.Add(t);                                // add the team to the list
            }//endforeach

            return list;        // return the unordered list that was just built
        }//endmethod
    }//endclass
}
